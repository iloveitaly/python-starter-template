###############################
# Scripts for Local Development
###############################

# watches all important python files and automatically restarts the worker process if anything changes
# this is done automatically for fastapi, but not for celery workers
PYTHON_WATCHMEDO := "uv run --with watchdog watchmedo auto-restart --directory=./ --pattern=*.py --recursive --"

GENERATED_PROCFILE := "tmp/Procfile"
GENERATED_LOCALIAS_CONFIG := "tmp/localias.yml"
GENERATED_HOST_ENV := "env/host.sh"

# TODO should add an option to not run workers, this is overkill most of the time

# run all dev-related code generation commands (hosts, localias, openapi, python)
# we don't guard against _dev_only since this needs to be run to bootstrap the application
dev_generate: _not_production dev_generate_hosts dev_generate_localias

dev_lint:
	# `--log-level=debug` for debugging
	# will report 0 commits scanned since it just outputs a massive diff and doesn't scan commits
	GIT_CONFIG_GLOBAL=/dev/null gitleaks git --log-level=debug --report-path=- --report-format json --redact=20 --no-banner
	# TODO link justfiles too

# start all of the services you need for development in a single terminal
[script]
dev: _dev_only localalias dev_kill
	just _banner_echo "Starting dev services"

	# TODO we should think about the worker command a bit more...should we use the same exact command? should we generate vs hardcode?
	cat << 'EOF' > {{GENERATED_PROCFILE}}
	# DO NOT EDIT, THIS FILE IS GENERATED BY `just dev`
	# contains all of the services required for local development
	py_dev: just py_dev
	py_worker: {{PYTHON_WATCHMEDO}} $(yq '.worker' Procfile --output-format yaml)
	py_scheduler: {{PYTHON_WATCHMEDO}} $(yq '.scheduler' Procfile --output-format yaml)
	js_dev: just js_dev
	py_generate: just py_generate --watch
	openapi: just js_generate-openapi --watch
	EOF

	mprocs --procfile={{GENERATED_PROCFILE}}

# kill all processes bound to server ports
[script]
dev_kill: _dev_only
	just _banner_echo "Killing all processes bound to server ports"

	for port in "$JAVASCRIPT_SERVER_PORT" "$PYTHON_SERVER_PORT" "$PYTHON_TEST_SERVER_PORT"; do
		echo "Checking for processes on port $port"
		pids=("${(@f)$(lsof -t -i :${port} 2>/dev/null || true)}")
		if [[ -n "$pids" ]]; then
			for pid in $pids; do
				kill -9 "$pid"
				echo "Killed process $pid on port $port"
			done
		else
			echo "No processes found on port $port"
		fi
	done

# this is currently the default global config path
GLOBAL_LOCALIAS_CONFIG := "~/.config/localias.yaml"

# need `[script]` for early exit
# run (or reload) daemon to setup local development aliases
[script]
localalias: _dev_only dev_generate_localias
	# We want to support running multiple concurrent projects with different localias configs
	# to do this, we need to use a global config, instead of simply loading from the project config.
	# This is why we iterate over the local config and use the native `set` to update the global config.
	yq eval 'to_entries | .[] | "localias -c {{GLOBAL_LOCALIAS_CONFIG}} set \"\(.key)\" \"\(.value)\""' {{GENERATED_LOCALIAS_CONFIG}} | zsh

	# if localias is already running, the above `set` will automatically reload localias with the new aliases
	if [[ "$(localias status)" == "daemon running with pid "* ]]; then
		just _banner_echo "Localias Daemon Already Running, Updated Aliases"
		exit 0
	fi

	localias -c {{GLOBAL_LOCALIAS_CONFIG}} start

	just _banner_echo "Global Local Alias Configuration"
	localias -c {{GLOBAL_LOCALIAS_CONFIG}} debug config --print

# TODO This needs to work for multiple MIS or tool version files. We should also try to make this more generic so it works for a MIS or a tool version file.
# TODO extract to my personal dotfiles as well
# TODO should change the CURRENT_BASE for py and other x.x.y upgrades
[script]
_mise_upgrade target_dir="": _dev_only
	if [[ -n "{{target_dir}}" ]]; then
		cd "{{target_dir}}"
	fi

	# Get current tools and versions only from paths within this repo
	TOOLS=("${(@f)$(mise list --current --json | jq -r --arg PWD "$PWD" '
		to_entries
		| map(select((.value[0].source.path // "") | startswith($PWD + "/.tool-versions")))
		| from_entries
		| keys[]
	')}")

	minor_updates_only=("python" "node")

	for TOOL in $TOOLS; do
			CURRENT=$(mise list --current --json | jq -r --arg TOOL "$TOOL" --arg PWD "$PWD" '
				to_entries
				| map(select((.value[0].source.path // "") | startswith($PWD + "/")))
				| from_entries
				| .[$TOOL][0].version
			')
			echo "Current version of $TOOL: $CURRENT"

			# do not automatically update a major version for python
			if (( ${minor_updates_only[(I)$TOOL]} )); then
					# Extract major.minor version
					CURRENT_BASE=$(echo "$CURRENT" | cut -d. -f1,2)
					echo "Current base version of $TOOL: $CURRENT_BASE"

					# Get latest version matching current major.minor
					LATEST=$(mise ls-remote "$TOOL" | grep -E "^${CURRENT_BASE}\.[0-9]+$" | sort -V | tail -n1)
			else
					# Extract major version
					CURRENT_BASE=$(echo "$CURRENT" | cut -d. -f1)
					echo "Current base version of $TOOL: $CURRENT_BASE"

					# Get latest version matching current major version
					LATEST=$(mise ls-remote "$TOOL" | grep -E "^${CURRENT_BASE}\.[0-9.]+$" | sort -V | tail -n1)
			fi

			if [[ -n $LATEST && $CURRENT != $LATEST ]]; then
					sed -i '' "s/^$TOOL .*/$TOOL $LATEST/" .tool-versions
					echo "Updated $TOOL: $CURRENT -> $LATEST"
			fi
	done

	# TODO https://discord.com/channels/1066429325269794907/1314301006992900117/1316773799688933406
	mise install

	git add .tool-versions

# sync the mise version to github actions yaml
_mise_gha_version_sync: _dev_only
	mise_version=$(mise --version | awk '{print $1}') && \
		yq e '.runs.steps.0.with.version = "'$mise_version'"' .github/actions/common-setup/action.yml -i

	git add .github/actions/common-setup/action.yml

# sync the parent/root pnpm + node version to the web subdirectory for railpack
_mise_web_version_sync: _dev_only
	# reads the current versions from the parent and applies them to the subdir
	# `requested_version` is the EXACT version specification in the parent, which is important otherwise if they drift,
	# mise will *not* use the older version and therefore the system node, etc would be used.
	mise --cd {{WEB_DIR}} use \
		node@$(mise list --current --json | jq -r '.node[0].requested_version') \
		pnpm@$(mise list --current --json | jq -r '.pnpm[0].requested_version')
	git add {{WEB_DIR}}/mise.toml

JAVASCRIPT_PACKAGE_JSON := WEB_DIR / "package.json"

# update package.json engines to match the current versions in .tool-versions
[script]
_js_sync-engine-versions: _dev_only
	NODE_VERSION=$(mise list --current --json | jq -r ".node[0].requested_version")
	PNPM_VERSION=$(mise list --current --json | jq -r ".pnpm[0].requested_version")

	# jq does not have edit in place
	# https://stackoverflow.com/questions/36565295/jq-to-replace-text-directly-on-file-like-sed-i
	tmp_package=$(mktemp)

	# >= vs ^ or ~ can cause weird compatibility issues such as:
	#   https://community.render.com/t/issue-with-deploy/26570/7
	# Always take a conservative approach with javascript system versions.

	jq "
		. + {
			engines: {
				node: \"^$NODE_VERSION\",
				pnpm: \"^$PNPM_VERSION\"
			}
	}" "{{JAVASCRIPT_PACKAGE_JSON}}" > "$tmp_package"

	mv "$tmp_package" "{{JAVASCRIPT_PACKAGE_JSON}}"

# upgrade mise, language versions, and essential packages
tooling_upgrade: _dev_only && _mise_upgrade _mise_web_version_sync _js_sync-engine-versions _mise_gha_version_sync
	mise self-update --yes
	mise upgrade

# upgrade everything: all packages on all languages, tooling, etc
upgrade: _dev_only tooling_upgrade js_upgrade py_upgrade
	playwright install
	just py_cli write-versions
	git add .service-versions

# expose the local server via ngrok for sharing your environment with others
[script]
ngrok:
	DIRECTORY=$(basename $(pwd)) && cat << EOF > $TMP_DIRECTORY/ngrok.yml
	version: 2
	authtoken: $(yq '.agent.authtoken' ~/.config/ngrok/ngrok.yml)
	tunnels:
		javascript_server:
			proto: http
			addr: https://${JAVASCRIPT_SERVER_HOST}
			domain: ${DIRECTORY}.ngrok-free.app
			host_header: ${JAVASCRIPT_SERVER_HOST}
		python_server:
			proto: http
			addr: https://${PYTHON_SERVER_HOST}
			domain: ${DIRECTORY}-api.ngrok-free.app
			host_header: ${PYTHON_SERVER_HOST}
	EOF

	ngrok start --all --config $TMP_DIRECTORY/ngrok.yml

PORT_RANGE_START := "8200"
HOST_ENV_TEMPLATE := '''

# use a non-standard port to avoid conflicts with other applications
export PYTHON_SERVER_PORT=$(( ${START_PORT} + ${PORT_OFFSET} ))
export PYTHON_TEST_SERVER_PORT=$(( ${START_PORT} + 1 + ${PORT_OFFSET} ))
export JAVASCRIPT_SERVER_PORT=$(( ${START_PORT} + 2 + ${PORT_OFFSET} ))
export FLOWER_PORT=$(( ${START_PORT} + 3 + ${PORT_OFFSET} ))

# only applicable in development, javascript is bundled in the py container in prod
export JAVASCRIPT_SERVER_HOST=${WORKTREE_PREFIX}${PROJECT_NAME}.localhost
export PYTHON_SERVER_HOST=api.${WORKTREE_PREFIX}${PROJECT_NAME}.localhost
export PYTHON_TEST_SERVER_HOST=api-test.${WORKTREE_PREFIX}${PROJECT_NAME}.localhost
export FLOWER_HOST=flower.${WORKTREE_PREFIX}${PROJECT_NAME}.localhost

# block bad hosts in fastapi. not required for development, but helpful to keep prod vs dev consistent
# in production, this is most likely only a single host but can support multiple hosts
export ALLOWED_HOST_LIST="${JAVASCRIPT_SERVER_HOST},${PYTHON_TEST_SERVER_HOST},${PYTHON_SERVER_HOST}"

# protocol is important, otherwise you'll get CORS errors in the browser
export VITE_PYTHON_URL="https://${PYTHON_SERVER_HOST}/"
export VITE_APP_BASE_URL="https://${JAVASCRIPT_SERVER_HOST}/"
'''

# generate host-specific env overrides (run once per worktree, or to reset main repo)
[script]
dev_generate_hosts:
	# detect if we're in a git worktree
	git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

	if [[ "$git_common_dir" == ".git" || -z "$git_common_dir" ]]; then
		# main repo - no prefix, no offset
		worktree_prefix=""
		port_offset=0
	else
		# worktree - use name as prefix and compute port offset
		worktree_name=$(basename "$PWD")
		worktree_prefix="${worktree_name}."
		port_offset=$(python3 -c "from hashlib import md5; name='${worktree_name}'; print((int(md5(name.encode()).hexdigest(), 16) % 50 + 1) * 10)")
		fi

	cat << EOF > {{GENERATED_HOST_ENV}}
	# NOTE: This file is auto-generated by 'just dev_generate_hosts', do not edit.

	START_PORT={{PORT_RANGE_START}}
	PROJECT_NAME={{PROJECT_NAME}}
	PORT_OFFSET=${port_offset}
	WORKTREE_PREFIX="${worktree_prefix}"
	EOF

	cat << 'EOF' >> {{GENERATED_HOST_ENV}}
	{{HOST_ENV_TEMPLATE}}
	EOF

	echo "{{GREEN}}Generated{{NORMAL}} {{CYAN}}{{GENERATED_HOST_ENV}}{{NORMAL}}"

[script]
dev_generate_localias:
	mkdir -p tmp

	cat << EOF > {{GENERATED_LOCALIAS_CONFIG}}
	# NOTE this file is auto-generated by 'just dev_generate_localias'
	#
	# subdomains are used so cookies set on the web domain can be passed to the API domain
	# in production, the same domain is used.

	# javascript/react router server
	# this is the main domain you'll interact with to manually test the site
	${JAVASCRIPT_SERVER_HOST}: ${JAVASCRIPT_SERVER_PORT}
	# dev py server
	${PYTHON_SERVER_HOST}: ${PYTHON_SERVER_PORT}
	# test py server
	${PYTHON_TEST_SERVER_HOST}: ${PYTHON_TEST_SERVER_PORT}
	# job monitoring (flower)
	${FLOWER_HOST}: ${FLOWER_PORT}
	EOF

# when a new worktree is created, we want to copy some of the generated files from the main repo
[script]
bootstrap_worktree:
		git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
		current_dir=$(pwd)

		# if we're not in a worktree, just exit
		if [[ "$git_common_dir" == ".git" ]] || [[ "$git_common_dir" == "$current_dir/.git" ]]; then
				echo "{{RED}}Not in a git worktree, skipping bootstrap{{NORMAL}}"
				exit 0
		fi

		original_dir_path=$(dirname "$git_common_dir")

		# copy a couple things from the main repo:
		# - env/*.local.*
		# - .ipython_history

		cp "$original_dir_path/env/"*.local.* env/ || true
		cp "$original_dir_path/.ipython_history" .

		# may need some `.local.` customizations in order to generate
		direnv allow .

		just dev_generate_hosts

		just py_setup
		just js_setup

		echo "Make sure to setup your database as well"

# Interactive Python Process Killer
[script]
py_signal:
    # 1. Define command
    list_cmd="lsof -a -d cwd -c python -t +d . 2>/dev/null | xargs ps -o pid,ppid,command -p 2>/dev/null | jc --ps | jq -r '.[] | \"\(.pid)\t\(.ppid)\t\(.command)\"' | column -t -s $'\t'"

    # 2. Check for processes
    if [[ -z "$(eval $list_cmd)" ]]; then
        echo "No python processes found in $(pwd)"
        exit 0
    fi

    # 3. Run FZF (Plain text only)
    eval "$list_cmd" | \
    fzf --header="ENTER:SIGTERM | ALT-ENT:SIGKILL | CTRL-T:Threads | CTRL-O:Coroutines" \
        --border --padding=1,1 \
        --border-label=" Python Process Manager " \
        --reverse \
        --bind "enter:execute(kill -15 {1})+change-border-label( Sent SIGTERM to PID {1} )+reload($list_cmd)" \
        --bind "alt-enter:execute(kill -9 {1})+change-border-label( Sent SIGKILL to PID {1} )+reload($list_cmd)" \
        --bind "ctrl-t:execute(kill -USR2 {1})+change-border-label( Sent USR2 to PID {1} )" \
        --bind "ctrl-o:execute(kill -USR1 {1})+change-border-label( Sent USR1 to PID {1} )"
