###############################
# Scripts for Local Development
###############################

# watches all important python files and automatically restarts the worker process if anything changes
# this is done automatically for fastapi, but not for celery workers
PYTHON_WATCHMEDO := "uv run --with watchdog watchmedo auto-restart --directory=./ --pattern=*.py --recursive --"

# TODO should add an option to not run workers, this is overkill most of the time
# start all of the services you need for development in a single terminal
[script]
dev: _dev_only local-alias dev_kill
	just _banner_echo "Starting dev services"

	# TODO we should think about the worker command a bit more...should we use the same exact command? should we generate vs hardcode?
	cat << 'EOF' > tmp/Procfile
	# DO NOT EDIT, THIS FILE IS GENERATED BY `just dev`
	# contains all of the services required for local development
	py_dev: just py_dev
	py_worker: {{PYTHON_WATCHMEDO}} $(yq '.worker' Procfile --output-format yaml)
	py_scheduler: {{PYTHON_WATCHMEDO}} $(yq '.scheduler' Procfile --output-format yaml)
	js_dev: just js_dev
	py_generate: just py_generate --watch
	openapi: just js_generate-openapi --watch
	EOF

	mprocs --procfile=tmp/Procfile

# kill all processes bound to server ports
[script]
dev_kill: _dev_only
	just _banner_echo "Killing all processes bound to server ports"

	for port in "$JAVASCRIPT_SERVER_PORT" "$PYTHON_SERVER_PORT" "$PYTHON_TEST_SERVER_PORT"; do
		echo "Checking for processes on port $port"
		pids=("${(@f)$(lsof -t -i :${port} 2>/dev/null || true)}")
		if [[ -n "$pids" ]]; then
			for pid in $pids; do
				kill -9 "$pid"
				echo "Killed process $pid on port $port"
			done
		else
			echo "No processes found on port $port"
		fi
	done

# this is currently the default global config path
GLOBAL_LOCALIAS_CONFIG := "~/.config/localias.yaml"

# need `[script]` for early exit
# run (or reload) daemon to setup local development aliases
[script]
local-alias: _dev_only
	# We want to support running multiple concurrent projects with different localias configs
	# to do this, we need to use a global config, instead of simply loading from the project config.
	# This is why we iterate over the local config and use the native `set` to update the global config.
	yq eval 'to_entries | .[] | "localias -c {{GLOBAL_LOCALIAS_CONFIG}} set \"\(.key)\" \"\(.value)\""' .localias.yaml | zsh

	# if localias is already running, the above `set` will automatically reload localias with the new aliases
	if [[ "$(localias status)" == "daemon running with pid "* ]]; then
		just _banner_echo "Localias Daemon Already Running, Updated Aliases"
		exit 0
	fi

	localias -c {{GLOBAL_LOCALIAS_CONFIG}} start

	just _banner_echo "Global Local Alias Configuration"
	localias -c {{GLOBAL_LOCALIAS_CONFIG}} debug config --print

# TODO This needs to work for multiple MIS or tool version files. We should also try to make this more generic so it works for a MIS or a tool version file.
# TODO extract to my personal dotfiles as well
# TODO should change the CURRENT_BASE for py and other x.x.y upgrades
[script]
_mise_upgrade target_dir="": _dev_only
	if [[ -n "{{target_dir}}" ]]; then
		cd "{{target_dir}}"
	fi

	# Get current tools and versions only from paths within this repo
	TOOLS=("${(@f)$(mise list --current --json | jq -r --arg PWD "$PWD" '
		to_entries
		| map(select((.value[0].source.path // "") | startswith($PWD + "/.tool-versions")))
		| from_entries
		| keys[]
	')}")

	minor_updates_only=("python" "node")

	for TOOL in $TOOLS; do
			CURRENT=$(mise list --current --json | jq -r --arg TOOL "$TOOL" --arg PWD "$PWD" '
				to_entries
				| map(select((.value[0].source.path // "") | startswith($PWD + "/")))
				| from_entries
				| .[$TOOL][0].version
			')
			echo "Current version of $TOOL: $CURRENT"

			# do not automatically update a major version for python
			if (( ${minor_updates_only[(I)$TOOL]} )); then
					# Extract major.minor version
					CURRENT_BASE=$(echo "$CURRENT" | cut -d. -f1,2)
					echo "Current base version of $TOOL: $CURRENT_BASE"

					# Get latest version matching current major.minor
					LATEST=$(mise ls-remote "$TOOL" | grep -E "^${CURRENT_BASE}\.[0-9]+$" | sort -V | tail -n1)
			else
					# Extract major version
					CURRENT_BASE=$(echo "$CURRENT" | cut -d. -f1)
					echo "Current base version of $TOOL: $CURRENT_BASE"

					# Get latest version matching current major version
					LATEST=$(mise ls-remote "$TOOL" | grep -E "^${CURRENT_BASE}\.[0-9.]+$" | sort -V | tail -n1)
			fi

			if [[ -n $LATEST && $CURRENT != $LATEST ]]; then
					sed -i '' "s/^$TOOL .*/$TOOL $LATEST/" .tool-versions
					echo "Updated $TOOL: $CURRENT -> $LATEST"
			fi
	done

	# TODO https://discord.com/channels/1066429325269794907/1314301006992900117/1316773799688933406
	mise install

	just _mise_version_sync
	git add .tool-versions


# sync the mise version to github actions yaml
_mise_version_sync: _dev_only
	mise_version=$(mise --version | awk '{print $1}') && \
		yq e '.runs.steps.0.with.version = "'$mise_version'"' .github/actions/common-setup/action.yml -i

	git add .github/actions/common-setup/action.yml

# upgrade mise, language versions, and essential packages
tooling_upgrade: _dev_only && _mise_upgrade (_mise_upgrade WEB_DIR) _js_sync-engine-versions
	mise self-update --yes
	mise upgrade

# upgrade everything: all packages on all languages, tooling, etc
upgrade: _dev_only tooling_upgrade js_upgrade py_upgrade
	playwright install
	just py_cli write-versions
	git add .service-versions

# expose the local server via ngrok for sharing your environment with others
[script]
ngrok:
	DIRECTORY=$(basename $(pwd)) && cat << EOF > $TMP_DIRECTORY/ngrok.yml
	version: 2
	authtoken: $(yq '.agent.authtoken' ~/.config/ngrok/ngrok.yml)
	tunnels:
		javascript_server:
			proto: http
			addr: https://${JAVASCRIPT_SERVER_HOST}
			domain: ${DIRECTORY}.ngrok-free.app
			host_header: ${JAVASCRIPT_SERVER_HOST}
		python_server:
			proto: http
			addr: https://${PYTHON_SERVER_HOST}
			domain: ${DIRECTORY}-api.ngrok-free.app
			host_header: ${PYTHON_SERVER_HOST}
	EOF

	ngrok start --all --config $TMP_DIRECTORY/ngrok.yml
